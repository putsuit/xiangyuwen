ym正则 是一种规则 检索替换 擅长处理模糊范围的字符串（用来解决字符串）
parseint（能转化成数字 不能就转化为NaN）
var re = /a/  /里面写的是匹配字符的规则/
new RegExp(匹配的字符串,“修饰符”)
\转意符   放在/a/这种前面 \n换行  遇到/n /s 之类的时候使用正则的时候需要使用\转意符  
正则.test（字符串）
查看某个字符串有没有这个字符  有就true  没有就是flase 
修饰符：
忽略大小写 i
/z/.test(str)
/z/i.test(str)忽略大小写 
search:查看指定的字符 所在的位子  没有返回-1   indexof(查找字符串)
search （/a/i）(字符串)
match:找到正则匹配的字符，返回值为数组   将匹配到的放入数组
\d 代表一个数字/\d/  从第一个数字开始找 只能找一个 碰到不是数字的就返回
量词:
	+至少一个 可以多个 写在里面

修饰符：g 找全局match(/\d+/g)放在外面

str.replace(字符串||则正,要替换的字符||回调的字符)  将匹配的字符替换成自己想要的字符
正则 | 或者  
function($0)  需要被替换的字符（当前匹配到的字符）   没查询一次就会调用函数一次
function($0,$1）$1索引值
function($0,$1,$2)$2 整个字符串
往后都是undefined
()1.子项：从左往右的一组的括号为子项  2.提权：提高优先级
/D 非数字
？要么有一个


[]里面的字符可以是任意一个

str.match(/1[A-Za-z]+2/) 大小写
str.match(/1[89]|[2-9][0-9]|100/.test('100'))

[\u4e00-\u9fa5]  中文区间范围
var n = 0;
for(var i=0;i<str.length;i++){
	if(/[\u4e00-\u9fa5]/.test(str[i])){
		n+=2
	}else{
		n++;
	}
}


^ 在[]中内排除

{} 范围 量词 {n,m}n起始位置  m结束位置
str.match(/a\d{1,4}c/g)

*{0,}最小一个 最多无限
量词都是形容d 写在里面

^不再[]中就是开始  $为结尾  某一段  整个一段

\s空格
str.replace（/<[^>]+>/g）


转意符
\w ：数字 字母 下划线  

\W 非数字字母下划线


\b 边界符  只要是符号就没有  replace(/\b/g,，“|”）会把非边界的用符号覆盖

\B 非边界

Array.form(转化成真数组)
	
() =>{} == function (){}

子项(a)\1  当序号打错了  会把整个字符串反回出来是str replace本次正则失效了 后面的都不执行
如果是march  找不到就会跟你返回空
如果重复项在该子项前面会被忽略  


































